## vue3和vue2的区别
vue3内部使用proxy来代替vue2的object.defineporperty来实现数据绑定，
vue2：每次页面数据被使用时，会收集所有使用到该数据的依赖，在属性或者数据发生变化时，会进行通知所有的依赖进行更新
vue3：使用proxy来进行进行代理，proxy可以直接监听数组和对象的变化，也可以监听到对象属性的增加和减少，性能也比object.defineporperty
我们如果需要访问一个属性，实际上是命中了vue对象的get方法，即使我们访问的属性也会命中他的get方法

## 对vue的源码有什么理解
1. compiler-sfc是编译模块，他会将以.vue结尾的文件全都编译成为可使用的js文件
2. compiler-dom是转换template标签内的代码
3. compiler-core是转换script内的代码，将一些vue独有的写法进行编译
4. run-time-dom将虚拟dom转换为真实dom，并处理dom绑定的事件
5. run-time-core创建虚拟节点和响应式系统，以及渲染函数，根据模板渲染成虚拟dom树
6. reactivity创建响应式api，提供给core使用

## vue3的优点
打包体积比vue2更小，由于使用ts重构了一遍代码所以支持性更好，逻辑抽离导致使用起码更加方便维护

## vue3和vue2diff算法差异
Vue 2.x使用的是双向指针遍历的算法，也就是通过逐层比对新旧虚拟DOM树节点的方式来计算出更新需要做的最小操作集合。但这种算法的缺点是，由于遍历是从左到右、从上到下进行的，当发生节点删除或移动时，会导致其它节点位置的计算出现错误，因此会造成大量无效的重新渲染。

Vue 3.x使用了经过优化的单向遍历算法，也就是只扫描新虚拟DOM树上的节点，判断是否需要更新，跳过不需要更新的节点，进一步减少了不必要的操作。此外，在虚拟DOM创建后，Vue 3会缓存虚拟DOM节点的描述信息，以便于复用，这也会带来性能上的优势。同时，Vue 3还引入了静态提升技术，在编译时将一些静态的节点及其子节点预先处理成HTML字符串，大大提升了渲染性能。

因此，总体来说，Vue 3相对于Vue 2拥有更高效、更智能的diff算法，能够更好地避免不必要的操作，并提高了渲染性能。

## mvvm是什么
MVVM是`Model-View-ViewModel`缩写，也就是把`MVC`中的`Controller`演变成`ViewModel`。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。

## vue中跨组件通信的方式
props：父对子
emit：子对父
provide和inject：组件库中使用可以爷孙使用
ref获取组件实例

## nexttick是宏任务还是微任务
nexttick优先使用微任务，在不支持微任务的环境下使用宏任务进行代替

## 宏任务和微任务的区别
js是单线程的，这意味着他每次只能执行一个任务，但是异步任务的处理就不纳入其中，为了处理异步任务，js分为了任务队列和调用栈，异步任务会被放入任务队列中，当调用栈为空时，任务队列中的异步任务会被取出放入调用栈中进行执行。
宏任务：游览器或者宿主环境提供的异步任务，不同类型的宏任务会被放入不同的任务队列中。每个宏任务执行完毕后会检查微任务队列，如果微任务队列为空则继续执行宏任务队列，像settimeout和setinterval是宏任务
微任务：由js引擎提供的异步任务，微任务队列只有一个，所有的微任务都放一起，每个宏任务执行完毕后会依次执行所有的微任务再继续执行下一个宏任务，像promise就是微任务


## 如何优化首屏加载速度
- 请求优化：CDN 将第三方的类库放到 CDN 上，能够大幅度减少生产环境中的项目体积，另外 CDN 能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。
- 缓存：将长时间不会改变的第三方类库或者静态资源设置为强缓存，将 max-age 设置为一个非常长的时间，再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源，好的缓存策略有助于减轻服务器的压力，并且显著的提升用户的体验
- 懒加载：当 url 匹配到相应的路径时，通过 import 动态加载页面组件，这样首屏的代码量会大幅减少，webpack 会把动态加载的页面组件分离成单独的一个 chunk.js 文件
- 预渲染：由于浏览器在渲染出页面之前，需要先加载和解析相应的 html、css 和 js 文件，为此会有一段白屏的时间，可以添加loading，或者骨架屏幕尽可能的减少白屏对用户的影响体积优化
- 合理使用第三方库：对于一些第三方 ui 框架、类库，尽量使用按需加载，减少打包体积
- 提高代码使用率：利用代码分割，将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程
- 封装：构建良好的项目架构，按照项目需求就行全局组件，插件，过滤器，指令，utils 等做一 些公共封装，可以有效减少我们的代码量，而且更容易维护资源优化
- 图片懒加载：使用图片懒加载可以优化同一时间减少 http 请求开销，避免显示图片导致的画面抖动，提高用户体验
- 使用 svg 图标：相对于用一张图片来表示图标，svg 拥有更好的图片质量，体积更小，并且不需要开启额外的 http 请求
- 压缩图片：可以使用 image-webpack-loader，在用户肉眼分辨不清的情况下一定程度上压缩图片
- treeshaking


## watch和watcheffect的区别