## 封装了函数化弹窗
需求：弹窗太多，而且基本内容都类似，只有些许不同，开发者内部希望使用函数化弹窗来进行简化开发步骤，开发时需要将开发精力完全集中在函数上，所以需要我们把所有逻辑封装到该hooks内
思路：既然是函数式弹窗，所以需要使用vnode来实现，设想是一个弹窗模板+一个弹窗hooks，接受如props等参数
步骤：
首先我们需要有一个最基础的弹窗组件，再使用appendto将这个弹窗组件插入到根组件位置，这里需要使用到一个hooks。在hooks中我们拿到当前调用者的实例，通过getcurrentinstance来拿到组件上的provides，这样就可以像弹窗组件进行传递
使用createVNode将组件实例创建最后使用render方法将其渲染。通过render(null)来将其销毁，并调用removechild将其移除

## 封装了打点库和token鉴权库
因为平时我们移动端项目种类众多，业务方频繁新增埋点需求，而且需要根据不同的uuid等多种数据来进行查询以便进行后续使用。所以我参与了移动端打点功能和接口鉴权功能的封装
问题1：后端接口需要二次鉴权即我需要先访问A平台拿到A平台token，再去B平台拿到最终token，而且荣耀的移动端访问量为百万级别，需要考虑到性能问题。
问题2：token存在时效性，有一些移动端接口需要无痛更新token
问题3：token需要绑定用户的手机，uuid、手机号以及用户平台等信息

问题4：打点涉及多种平台，包括h5，移动端项目，web管理后台项目都需要进行上报打点。
问题5：打点需要上报多种情况，数据请求失败，数据请求成功，用户成功查看内容（使用是否成功曝光来进行监测），数据请求具体内容，数据为空异常，网络异常，用户移除或不喜欢的数据
问题6：为了优化使用体验，使用该库时，只需要关心打点内容和打点点位以及具体情况，其余的用户手机信息，uuid，版本号，上报的移动端是什么等内容都进行封装好
问题7：环境不同切换不同的打点位置

解决方案：
鉴权：实现无痛刷新。每次获取Atoken和Btoken的时候都记录时间，以便和内部储存的时间进行检查是否过期，如果第一步检查就已经过期则先看最终token是否过期，如果最终token过期则无需发起刷新token请求，如果最终token过期则检查Atoken是否过期。此时我们需要设置一个标识用来记录是否正在无痛刷新token。该标识为全局的，一旦标识为正在刷新token则暂停所有的请求，把请求推入一个数组，然后等待token无痛刷新完再实行数组

打点：初始化时只需要传入环境进行生成即可，默认根据process.env.NODE_ENV来进行判断生产环境，使用类将整个打点逻辑进行封装，初始化时获取所有的用户参数，类似uuid这种，并将打点使用的常用信息绑定到类上，接下来使用类，创建曝光打点，失败打点，请求打点等多种打点方式，并暴露出来api供给开发者使用，开发者只需要使用暴露出来的api进行调用即可， 开发者还可以传入自动以内容到content字段内，从content字段会默认覆盖掉其他字段



## 封装了函数化表单


## 封装了大文件上传功能
步骤：
- 使用file.slice功能来将文件切割成固定的大小，也可支持断点续传等功能
- 封装一个utils，使用哈希值生成文件唯一标识，用于秒传和断点续传，使用的spark-md5来进行
- 每次上传成根据后端查询是否有对应的文件，如果有则直接返回成功上传
- 因为性能的原因，我们还需要进行控制并发，最多只能有三个切片进行上传