## 1.pick
ts内置的pick方法。用于从一个类型中选出我们需要的几个属性
常见用法：
```typescript
pick<T,K>
//其中T代表选择的类型
//K代表选择的属性
type selectType = pick<typeFather,'name'>
//selectType代表只有name属性的子类，注意这样的筛选会把name对应的类型也进行选择
```

比如我们有一个类型
``` ts
interface typefather {
	name:string,
	age:number
}
```
而我们只想要他的name属性
```ts
interface selectedType = pick<typefather,'name'>
//{ name:string}
```

如何实现pick呢
需要用到一些新的关键字
```  ts
type MyPick<T, K extends keyof T> = { [key in K] : T[key] }
```
### 1、keyof关键字

`keyof` 是 TypeScript 中的一个关键字，用于获取一个类型的所有属性名组成的联合类型。

例如，我们可以使用 `keyof` 关键字来获取一个类型的所有属性名：
``` ts
type Person = { name: string; age: number }; type Keys = keyof Person; // "name" | "age"
```
### 2、extends关键字

我们都知道 `extends` 表示继承，但是这里却不是继承的意思，而是**泛型约束**。实际上，`extends` 可以用于约束泛型类型参数、定义类型继承关系和条件类型的判断。

当 `extends` 用于约束泛型类型参数，例如，`T extends SomeType` 表示泛型类型参数， `T` 必须是 `SomeType` 或其子类型。

### 3、in关键字

在映射类型中，`in` 关键字用于遍历一个类型的属性名，并对每个属性进行相应的操作。需要先获取所有属性组成的联合类型，然后通过 `in` 去遍历联合类型。

例如，我们可以使用 `in` 关键字将一个类型的所有属性变为可选属性：
``` ts
type Person = { name: string; age: number }; 
type OptionalPerson = { [K in keyof Person]?: Person[K] };
type Result = OptionalPerson; // { name?: string; age?: number; }

```
在上述例子中，`OptionalPerson` 是一个映射类型，它遍历 `Person` 类型的属性名，并将每个属性变为可选属性。

需要注意的是，这里的 `K` 只是一个占位符，你可以使用任意合法的标识符来代替。例如，可以使用 `P`、`Prop` 等等。


## `T[number]`和`T['length']`
ts中常用的数组类型还有元组，它是一个固定了类型和元素个数的数组，它的元素位置也是固定的
如果我们需要获取元组中的每个元素，则需要使用`T[number]`语法，这个关键写法代表访问元组中的每个成员并供遍历
如果我们需要获取到元组的长度。则需要使用`T['length']`语法，这个关键写法代表返回元祖的固定长度
**如果元祖后 带有as const关键字**
则表示这个元组的所有成员位置，类型和值都不会发生变化
```ts
const tuple = ['apple','banna'] as const
const ans = tuple[number]
// 'apple' 'banna'
const len = tuple['length']
// 2
```

其实这两个关键写法也可以用来针对数组生效，但是返回的结果会有一些不一样。
比如
``` ts
const tuple:string[] = ['apple','banna'] 
const ans = tuple[number]
// string
const len = tuple['length']
// number
```
想想看为什么会结果不一样呢？
关于答案，这就牵扯到了元组和数组不一样的地方。
元组==>长度固定，元素类型固定位置固定
数组==>类型一致，长度不固定，位置不固定
因为数组的长度是可变化的，故使用`T['length']`返回的结果只会是number
因为数组的元素位置是可变化且值也可变化，故使用`T[number]`返回的结果只会是数组的统一类型



















