kmp用于快速匹配字符串。使用一个被称为next数组的额外模式串用于记忆之前的匹配次数。用来减少最终的匹配次数。减少时间消耗。

**何为额外模式串？**
1：当开始匹配时，比如字符串为abadabab，而子串为abab。
2：开始匹配到第一个不匹配的下标时。可以注意到abab和abaf的前两位是相同的。
3：故。可以直接略过前两位的匹配。
 a b a d a b a b
 a b a b
 可以直接从第二位开始匹配
 a b a d a b a b
       a b a b
4：发现还是不匹配。但是因为前两位还是相同。故我们可以再直接跳过两位
	 a  b  a  d  a b a b
                     a b a b 
5：这样就达成了直接匹配。中间略过了很多步骤。
6：这种匹配项。被称为最长前后缀



**如何在运行的时候知道额外数组串应该移动多少位？**
答案是算出当前的最长相同前后缀
比如
aabaaf这里最长前后缀就是0
aabaab这里的最长前后缀就是3
ababa的最长前后缀也是3
于是我们可以这样来进行技术
a a b a a f
第一个下标没有最长前后缀，于是他的位移值为0
第二个下标有最长前后缀为a，于是他的位移值为1
第三个下标没有最长前后缀，于是他的位移值为0
第四个下有最长前后缀a，于是他的位移值为1
第五个下标有最长前后缀aa，于是他的位移值为2
第六个下标没有最长前后缀，于是他的位移值为0



**位移值和如何减少匹配次数有什么关系呢**
其实位移值就是相当于一个自我记忆的过程。或者说取巧的位移步骤。
比如
子串：abcaby
和
串：abxabcabcaby
我们可以先得出位移值
a b c a b y 的位移值为
0 0 01 2 0
开始匹配

abxabcabcaby
abcaby
第一次不匹配是下标3，寻找子串下标3的前一位位置值，得出0。意思是x和子串的第一位开始进行匹配
<font size="3">这里的位移概念是，子串的多少位可以和失误位置之前多少位重合</font>
abxabcabcaby
  abcaby
第二次匹配。由于X和a不匹配，寻找a对应的下标值。发现是第一个且不匹配。移动1
abxabcabcaby
     abcaby
第三次匹配、由于是最后一位。寻找y对应的下标值。发现之前一位是2。于是为之前2位不需要重新匹配。现在出问题的位置直接与子串的第二位开始进行匹配
                       *
a b x a b c a b c a b y
                 a b c a b y



